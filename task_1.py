"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение. Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""
from random import randint
from timeit import timeit

# Example_1 Сортировка без проверки


def array_sort_default(array):
    for i in range(len(array) - 1):
        for j in range(len(array) - i - 1):
            if array[j] > array[j + 1]:
                array[j], array[j+1] = array[j+1], array[j]
    return array


# Example_2 Сортировка с условием

def array_sort(array):
    flag = True
    while flag:
        flag = False
        for i in range(len(array) - 1):
            if array[i] > array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                flag = True
    return array


if __name__ == '__main__':
    count = int(input('Введите количество элементов массива: '))
    items_list = []
    for i in range(count):
        items_list.append(randint(-100, 101))
    print(f'Исходный массив - {items_list}')
    print('Время сортировки массива без проверки условия -',
          timeit("array_sort_default(items_list[:])", globals=globals(), number=15000))  # 0.09713877299509477
    print('Время сортировки массива с условием -',
          timeit("array_sort(items_list[:])", globals=globals(), number=15000))  # 0.12431695499981288
    print(f'Отсортированный массив - {array_sort(items_list)}')

# Время, затраченное на выполнение сортировки массива с условием,
# когдаза проход по списку не совершается ни одной сортировки всегда будет одинаково, либо выше
# времени выполнения функции без условия за счет дополнительной проверки самого условия.
# Прирост в скорости получится лишь в том случае, если на вход функции попадет уже
# отсортированный массив.


